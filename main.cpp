#ifdef _WIN32    #include <SDL.h>    #include <SDL_image.h>    #include <SDL_ttf.h>    #include <SDL_mixer.h>#elif __APPLE__    #include <SDL2/SDL.h>    #include <SDL2_image/SDL_image.h>    #include <SDL2_ttf/SDL_ttf.h>    #include <SDL2_mixer/SDL_mixer.h>#endif#include "Map.h"#include "Tile.h"#include "Functions.h"#include "textbox.h"#include "button.h"#include "animation.h"#include "playerinfo.h"#include "particle.h"// #include "slider.h"#include <iostream>#include <string>#include <vector>#include <cstdlib>#include <cstdio>#include <cmath>using std::cout;using std::cin;using std::endl;using std::vector;using std::string;// * Screen dimension constantsconst int TILE_SIZE = 64;const int WINDOW_WIDTH = 1024;//16*TILE_SIZE;const int WINDOW_HEIGHT = 704;//11*TILE_SIZE;const int TOTAL_IMAGES = 1;const int SCROLL_SPEED = 15;const int WALKING_DELAY = 20;const int MUSIC_VOL = 0;//MIX_MAX_VOLUME/2;const int EFFECTS_VOL = MIX_MAX_VOLUME/2;int main( int argc, char*argv[] ){    init();    /* * * * * * * * * * * * */    /* Initialize variables  */    /* * * * * * * * * * * * */    int mode = 0;    int mine_Width = 50;    int mine_Height = 50;    int numOfMines = 1000;    SDL_Point mouse = {0,0};    int minMapBorderX = 0;    int maxMapBorderX = ((mine_Width+2)*TILE_SIZE) - WINDOW_WIDTH;    int minMapBorderY = 0;    int maxMapBorderY = ((mine_Height+2)*TILE_SIZE) - WINDOW_HEIGHT;    int tempOffsetX = 0;    int tempOffsetY = 0;    bool close = false;    vector<int> scores(0);    loadPrevScores(scores);    /* * * * * * * * * * * * */    /*     Set up audio      */    /* * * * * * * * * * * * */    // * Music Chunks    Mix_Chunk *boom = NULL;    Mix_Chunk *dig = NULL;    Mix_Chunk *music = NULL;    Mix_Chunk *splat[4];    // * Allocate channels    // * (Channel 0) for sound effects    // * (Channel 1) for background music    Mix_AllocateChannels(2);    // * Sets channel 0 to 1/5 volume (Sound effects)    // * Sets channel 1 to 1/2 volume (Background music)    Mix_Volume(0,EFFECTS_VOL);    Mix_Volume(1,MUSIC_VOL);    //* Load music files    boom= Mix_LoadWAV( "Resources/explode.wav" );    dig= Mix_LoadWAV( "Resources/dig.wav" );    music= Mix_LoadWAV("Resources/background1.wav");    splat[0]= Mix_LoadWAV("Resources/splat1.wav");    splat[1]= Mix_LoadWAV("Resources/splat2.wav");    splat[2]= Mix_LoadWAV("Resources/splat3.wav");    splat[3]= Mix_LoadWAV("Resources/splat4.wav");    // * Play background music (infinite loop - Channel 1)    Mix_PlayChannel(1, music, -1 );    /* * * * * * * * * * * * */    /*  Create SDL objects   */    /* * * * * * * * * * * * */    // * Window width and height    SDL_Window *win  = SDL_CreateWindow(        "Mine Game",        100,               // * Initial x position        100,               // * Initial y position        WINDOW_WIDTH,      // * Width (In pixels)        WINDOW_HEIGHT,     // * height (In pixels)        SDL_WINDOW_OPENGL  // * Flags - See below    );    // * Creates the renderer    SDL_Renderer * renderer = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED);    SDL_Event ev;    // * Cursors    SDL_Cursor * shovel = SDL_CreateColorCursor(IMG_Load("Resources/cursorx48.png"),0,0);    SDL_Cursor * crosshair = SDL_CreateColorCursor(IMG_Load("Resources/Crosshair.png"),24,24);    SDL_SetCursor(crosshair);    // * Set background color    SDL_SetRenderDrawColor(renderer, 173, 216, 230, 255);    SDL_RenderPresent(renderer);    // * Load textbox font    TTF_Font *fontRaleway=TTF_OpenFont("Resources/Raleway-Medium.ttf", 15);    if(!fontRaleway)    {        printf("TTF_OpenFont: %s\n", TTF_GetError());    }    // * Load another font    TTF_Font *fontCalibri=TTF_OpenFont("Resources/calibri.ttf", 18);    if(!fontCalibri)    {        printf("TTF_OpenFont: %s\n", TTF_GetError());    }    // * Set up rectangle for referencing spritesheet    int numOfImages = 21;    vector<SDL_Rect> imageVector(numOfImages);    loadImages(imageVector,numOfImages,renderer);    // * Create and draw map    Map mainMap(renderer, mine_Width,mine_Height,numOfMines);    mainMap.setBounds(minMapBorderX,minMapBorderY,maxMapBorderX,maxMapBorderY);    mainMap.tileSize(TILE_SIZE);    mainMap.draw();    // * Create textbox and print initial output    Textbox textbox(renderer,fontCalibri,win);    textbox.add("Welcome to the mine game.");    textbox.add("There are " + toString(mainMap.getTotalMines()) + " mines on this map.");    textbox.add("You get " + toString(mainMap.digs_) + " digs and " + toString(mainMap.rockets_) + " rockets.");    textbox.add("Click the 'score' button to bring up score history.");    textbox.add("Click the menu to bring up other info.");    textbox.add("Press ESC to close any interface.");    textbox.draw();    // - Create Buttons -    vector<Button> gameButtons(0);    // * Menu    gameButtons.push_back(Button(renderer,win,fontRaleway,WINDOW_WIDTH-90,10,80,40));    gameButtons[0].draw("Menu");    // * Score    gameButtons.push_back(Button(renderer,win,fontRaleway,WINDOW_WIDTH-90-130,10,120,40));    gameButtons[1].draw("Score: " + toString(mainMap.getScore()));    // * Rockets    gameButtons.push_back(Button(renderer,win,fontRaleway,WINDOW_WIDTH-90-130-130,10,120,40));    gameButtons[2].draw("Rockets: " + toString(mainMap.rockets_));    // * Digs    gameButtons.push_back(Button(renderer,win,fontRaleway,WINDOW_WIDTH-90-130-130-110,10,100,40));    gameButtons[3].draw("Digs: " + toString(mainMap.digs_));    // * Mines    gameButtons.push_back(Button(renderer,win,fontRaleway,WINDOW_WIDTH-90-130-130-110-120,10,110,40));    gameButtons[4].draw("Mines: " + toString(mainMap.getTotalMines()));    // * Create character    Animation character(renderer,win,mainMap,textbox,gameButtons,"Resources/walking.png",8,TILE_SIZE,WALKING_DELAY);    SDL_Point charRotPt = {30,111};    character.rotpt(charRotPt);    character.draw();    // * Create rocket    Animation rocket(renderer,win,mainMap,textbox,gameButtons,"Resources/rocket.png",4,TILE_SIZE,10);    SDL_Point rotpt = {79,16};    // * Set point of rotation for img    rocket.rotpt(rotpt);    // * Load textures    SDL_Texture * texture = SDL_CreateTextureFromSurface(renderer,IMG_Load("Resources/tiles.png"));    SDL_Texture * volButton = SDL_CreateTextureFromSurface(renderer,IMG_Load("Resources/VolumeButton.png"));    SDL_Texture * volBack = SDL_CreateTextureFromSurface(renderer,IMG_Load("Resources/VolumeBar.png"));    SDL_Texture * menuBackground = SDL_CreateTextureFromSurface(renderer,IMG_Load("Resources/GameMenu2.png"));    //set up volume sliders for menus    Slider musicVol(renderer,win,volBack,volButton);    musicVol.setNobPos(MUSIC_VOL);    Slider effectsVol(renderer,win,volBack,volButton);    effectsVol.setNobPos(EFFECTS_VOL);    SDL_RenderPresent(renderer);    // * Initialize particle engine    ParticleEngine particles;    ParticleEngine particles2;    int shakecount = 0;    int soundcount = 0;    int startDie = 0;    // * Initialize death message    int dChoose;    const int NUMD = 10;    string dMessages[NUMD];    dMessages[0] = "You will not be missed";    dMessages[1] = "Existence is meaningless";    dMessages[2] = "Accept sadness";    dMessages[3] = "Alone";    dMessages[4] = "Nothing we do matters";    dMessages[5] = "We create our own Hell";    dMessages[6] = "We live, We die, We are forgotten";    dMessages[7] = "All is quiet now";    dMessages[8] = "Why did I come here?";    dMessages[9] = "What led to this?";    srand(time(0));    SDL_Color textcolor = {255,255,255};    SolidText deadText(renderer,win,fontCalibri,130,10,120,40,textcolor);    while(!close)    {        if (mode == 2)        {            if (startDie ==0)            {                dChoose = (rand() % NUMD);                Mix_PlayChannel(1, boom, 0 );                Mix_PlayChannel(0, splat[(rand() % 3 )], 0 );                particles.start(renderer, 200,character.posX()+32- mainMap.offsetX(),character.posY()+160- mainMap.offsetY(),"Resources/Blood1.png",3,64,64);                particles2.splat(renderer, 6,character.posX()+32- mainMap.offsetX(),character.posY()+160- mainMap.offsetY(),"Resources/Blood1.png",3,300,300,win);                shakecount = 50;                startDie =1;            }            while (SDL_PollEvent(&ev) != 0)            {                if( ev.type == SDL_QUIT )                {                    close = true;                    if(mainMap.getScore() != 0){                        scores.push_back(mainMap.getScore());                        quicksort(scores,0,scores.size()-1);                    }                }                else if (ev.type == SDL_MOUSEBUTTONDOWN)                {                    SDL_GetMouseState(&mouse.x,&mouse.y);                    if(SDL_PointInRect(&mouse,gameButtons[0].rect()))                    {                        int code = gameButtons[0].pauseMenu(ev,musicVol,effectsVol);                        if(code == 0)                        {                            close = true;                            if(mainMap.getScore() != 0)                            {                                scores.push_back(mainMap.getScore());                                quicksort(scores,0,scores.size()-1);                            }                        }                        else if (code == 1)                        {                            if(mainMap.getScore() != 0)                            {                                scores.push_back(mainMap.getScore());                                quicksort(scores,0,scores.size()-1);                            }                            mainMap.restart();                            character.restart();                            SDL_RenderPresent(renderer);                            shakecount = 0;                            soundcount = 0;                            startDie = 0;                            mode = 0;                        }                        else if(code == 3)                        {                            int subcode = gameButtons[0].mainMenu(ev,menuBackground,musicVol,effectsVol,scores);                            if(subcode == 1)                            {                                if(mainMap.getScore() != 0)                                {                                    scores.push_back(mainMap.getScore());                                    quicksort(scores,0,scores.size()-1);                                }                                mainMap.restart();                                character.restart();                                shakecount = 0;                                soundcount = 0;                                startDie = 0;                                mode = 0;                            }                            else if (subcode == 0)                            {                                close = true;                                if(mainMap.getScore() != 0)                                {                                    scores.push_back(mainMap.getScore());                                    quicksort(scores,0,scores.size()-1);                                }                            }                        }                    }                    if(SDL_PointInRect(&mouse,gameButtons[1].rect()))                    {                        int code = gameButtons[1].showScoresheet(ev,scores);                        if(code == 0){                            close = true;                            if(mainMap.getScore() != 0)                            {                                scores.push_back(mainMap.getScore());                                quicksort(scores,0,scores.size()-1);                            }                        }                    }                }            }            SDL_Delay(10);            SDL_RenderClear(renderer);            mainMap.draw();            textbox.draw();            particles.update();            particles.draw();            particles2.update();            particles2.draw();            if (shakecount >0)            {                Mix_PlayChannel(2, splat[(rand() % 3 )], 0 );                mainMap.addOffsetX((rand() % 40 )-20);                mainMap.addOffsetY((rand() % 40 )-20);                --shakecount;            }            else{                deadText.draw(dMessages[dChoose]);            }            for(int i = 0; i < gameButtons.size(); i++)            {                gameButtons[i].draw();            }            SDL_RenderPresent(renderer);        }        else if (mode == 1)        {            SDL_GetMouseState(&mouse.x, &mouse.y);            if (mouse.y < WINDOW_WIDTH/5)            {                double tempSpeed = 1.00-(mouse.x/(WINDOW_WIDTH/5.00));                mainMap.subOffsetX(SCROLL_SPEED*tempSpeed);                /* Note: the reason it checks here instead of the if statement above                is because even with the check it is possible to go too fast                and go off the edge of the screen                */                if (mainMap.offsetX() < mainMap.minMapBorderX())                {                    mainMap.offsetX(mainMap.minMapBorderX());                }                SDL_RenderClear(renderer);                mainMap.draw();                character.draw();                textbox.draw();                for(int i = 0; i < gameButtons.size(); i++)                {                    gameButtons[i].draw();                }                SDL_RenderPresent(renderer);            }            else if (mouse.x > WINDOW_WIDTH-(WINDOW_WIDTH/5))            {                double x = WINDOW_WIDTH - (WINDOW_WIDTH/5.00);                double tempSpeed = (mouse.x-x)/ (WINDOW_WIDTH-x);                mainMap.addOffsetX(SCROLL_SPEED*tempSpeed);                /* Note: the reason it checks here instead of the if statement above                is because even with the check it is possible to go too fast                and go off the edge of the screen                */                if (mainMap.offsetX() > mainMap.maxMapBorderX())                {                    mainMap.offsetX(mainMap.maxMapBorderX());                }                SDL_RenderClear(renderer);                mainMap.draw();                character.draw();                textbox.draw();                for(int i = 0; i < gameButtons.size(); i++)                {                    gameButtons[i].draw();                }                SDL_RenderPresent(renderer);            }            if (mouse.y < WINDOW_HEIGHT/5)            {                double tempSpeed = 1.00-(mouse.y/(WINDOW_HEIGHT/5.00));                mainMap.subOffsetY(SCROLL_SPEED*tempSpeed);                /* Note: the reason it checks here instead of the if statement above                is because even with the check it is possible to go too fast                and go off the edge of the screen                */                if (mainMap.offsetY() < mainMap.minMapBorderY())                {                    mainMap.offsetY(mainMap.minMapBorderY());                }                SDL_RenderClear(renderer);                mainMap.draw();                character.draw();                textbox.draw();                for(int i = 0; i < gameButtons.size(); i++)                {                    gameButtons[i].draw();                }                SDL_RenderPresent(renderer);            }            else if (mouse.y > WINDOW_HEIGHT-(WINDOW_HEIGHT/5))            {                double x = WINDOW_HEIGHT - (WINDOW_HEIGHT/5.00);                double tempSpeed = (mouse.y-x)/ (WINDOW_HEIGHT-x);                mainMap.addOffsetY(SCROLL_SPEED*tempSpeed);             /* Note: the reason it checks here instead of the if statement above             is because even with the check it is possible to go too fast             and go off the edge of the screen             */             if (mainMap.offsetY() > mainMap.maxMapBorderY())             {                mainMap.offsetY(mainMap.maxMapBorderY());             }                SDL_RenderClear(renderer);                mainMap.draw();                character.draw();                textbox.draw();                for(int i = 0; i < gameButtons.size(); i++)                {                    gameButtons[i].draw();                }                SDL_RenderPresent(renderer);            }            SDL_Delay(10);            while(SDL_PollEvent(&ev) != 0)            {                if(ev.type == SDL_QUIT)                {                    close = true;                    if(mainMap.getScore() != 0)                    {                        scores.push_back(mainMap.getScore());                        quicksort(scores,0,scores.size()-1);                    }                }                else if(ev.type == SDL_KEYDOWN ||ev.type == SDL_MOUSEBUTTONDOWN)                {                    SDL_RenderClear(renderer);                    mode = 0;                    mainMap.offsetX(tempOffsetX);                    mainMap.offsetY(tempOffsetY);                    mainMap.draw();                    character.draw();                    textbox.draw();                    for(int i = 0; i < gameButtons.size(); i++)                    {                        gameButtons[i].draw();                    }                    SDL_RenderPresent(renderer);                }            }        }        else if (mode == 0)        {        // * Handle events            while(SDL_PollEvent(&ev) != 0)            {            // * If Quit                if(ev.type == SDL_QUIT)                {                    close = true;                    if(mainMap.getScore() != 0)                    {                        scores.push_back(mainMap.getScore());                        quicksort(scores,0,scores.size()-1);                    }                }                // * Mouse event displays a marker on the screen where the mouse is.                // * This should probably be moved to a mouse function                // * A number of key events that simply change the "offset" value.                // * All other functions will have to take this value into consideration                else if( ev.type == SDL_KEYUP )                {    			  // * Select surfaces based on key press                  switch( ev.key.keysym.sym )                  {                    // * Press t - Adjust volume in terminal by putting a value (Not completed yet - Future volume bar)                    case SDLK_t:                    {                        int vol = 0;                        cin >> vol;                        Mix_Volume(1, vol);                    } break;                    case SDLK_v:                    {                    } break;                    case SDLK_c:                    {                        mode = 1;                        tempOffsetX = mainMap.offsetX();                        tempOffsetY = mainMap.offsetY();                    } break;                    case SDLK_w:                    case SDLK_UP:                    {                        if(mainMap.offsetY() > -(WINDOW_HEIGHT/2))                        {                            if (character.mapY() != 0)                            {                                mainMap.charStepInto(character.mapX(), character.mapY()-1, &mode);                                character.up();                            }                            //mainMap.charStepInto(tempOffsetX,tempOffsetY);                        }                    } break;                    case SDLK_a:                    case SDLK_LEFT:                    {                        if(mainMap.offsetX() > -(WINDOW_WIDTH/2))                        {                            if (character.mapX() > 0)                            {                                mainMap.charStepInto(character.mapX()-1, character.mapY(), &mode);                                character.left();                            }                        }                    } break;                    case SDLK_s:                    case SDLK_DOWN:                    {                        if(mainMap.offsetY() < (((mainMap.height()-1) * mainMap.tileSize()) - (WINDOW_HEIGHT/2))){                            if (character.mapY() < (mainMap.height()-1))                            {                                mainMap.charStepInto(character.mapX(), character.mapY()+1, &mode);                                character.down();                            }                        }                    } break;                    case SDLK_d:                    case SDLK_RIGHT:                    {                        if(mainMap.offsetX() < (((mainMap.width()-1) * mainMap.tileSize()) - (WINDOW_WIDTH/2))){                            if (character.mapX() < (mainMap.width()-1))                            {                                mainMap.charStepInto(character.mapX()+1, character.mapY(), &mode);                                character.right();                            }                        }                    } break;                }                mainMap.charStepInto(character.mapX(), character.mapY(),&mode);            }            // * This checks for mouse move, mouse down, and mouse up            else if( ev.type == SDL_MOUSEMOTION /*|| ev.type == SDL_MOUSEBUTTONDOWN || ev.type == SDL_MOUSEBUTTONUP */)            {                // * Clear and display the base map                SDL_RenderClear(renderer);                mainMap.draw();                // * Get mouse position                SDL_GetMouseState( &mouse.x, &mouse.y);                // * Position of person/camera (3 by 3)                if ((character.posX() - mainMap.tileSize() - mainMap.offsetX() - 8) < mouse.x && mouse.x < (character.posX() + 2*mainMap.tileSize() - mainMap.offsetX() - 8) &&                    (character.posY() - mainMap.tileSize() - mainMap.offsetY() - 8) < mouse.y && mouse.y < (character.posY() + 2*mainMap.tileSize() - mainMap.offsetY() - 8))                {                    // * If in the 3 by 3 then set the cursor to shovel                    SDL_SetCursor(shovel);                }                else                {                    // * If anything beyond the 3 by 3 then set the cursor to crosshair                    SDL_SetCursor(crosshair);                }                // * Put the marker on the mouse tile                int checkX = ((mouse.x+mainMap.offsetX())/mainMap.tileSize());                int checkY = ((mouse.y+mainMap.offsetY())/mainMap.tileSize());                for(int i = 0; i < mainMap.height(); i++)                {                    for(int j = 0; j < mainMap.width(); j++)                    {                        if (checkX == j && checkY == i)                        {                            SDL_Rect rectangleShowToRenderer;                            rectangleShowToRenderer.x = (j*mainMap.tileSize()) - mainMap.offsetX();                            rectangleShowToRenderer.y = (i*mainMap.tileSize()) - mainMap.offsetY();                            rectangleShowToRenderer.w = mainMap.tileSize();                            rectangleShowToRenderer.h = mainMap.tileSize();                            SDL_RenderCopy(renderer,texture,&imageVector[12],&rectangleShowToRenderer);                        }                    }                }                // * Render the text box that displays mines left                character.draw();                textbox.draw();                for(int i = 0; i < gameButtons.size(); i++)                {                    gameButtons[i].draw();                }                SDL_RenderPresent(renderer);            }            else if(ev.type == SDL_MOUSEBUTTONDOWN)            {                // * Redraw map                SDL_RenderClear(renderer);                //displayMap(mainMap,renderer,texture,imageVector,offsetX,offsetY);                mainMap.draw();                character.draw();                textbox.draw();                for(int i = 0; i < gameButtons.size(); i++)                {                    gameButtons[i].draw();                }                // * Get mouse coordinates                SDL_GetMouseState(&mouse.x, &mouse.y);                if(SDL_PointInRect(&mouse,gameButtons[0].rect()))                {                    int code = gameButtons[0].pauseMenu(ev,musicVol,effectsVol);                    if(code == 0)                    {                        close = true;                        if(mainMap.getScore() != 0)                        {                            scores.push_back(mainMap.getScore());                            quicksort(scores,0,scores.size()-1);                        }                    }                    else if (code == 1)                    {                        if(mainMap.getScore() != 0)                        {                            scores.push_back(mainMap.getScore());                            quicksort(scores,0,scores.size()-1);                        }                        mainMap.restart();                        character.restart();                        mainMap.draw();                        character.draw();                        textbox.draw();                        gameButtons[0].draw();                        gameButtons[1].draw("Score: " + toString(mainMap.getScore()));                        gameButtons[2].draw("Rockets: " + toString(mainMap.rockets_));                        gameButtons[3].draw("Digs: " + toString(mainMap.digs_));                        gameButtons[4].draw("Mines: " + toString(mainMap.getTotalMines()));                        SDL_RenderPresent(renderer);                    }                    else if(code == 3)                    {                        int subcode = gameButtons[0].mainMenu(ev,menuBackground,musicVol,effectsVol,scores);                        if(subcode == 1)                        {                            if(mainMap.getScore() != 0)                            {                                scores.push_back(mainMap.getScore());                                quicksort(scores,0,scores.size()-1);                            }                            mainMap.restart();                            character.restart();                            mainMap.draw();                            character.draw();                            textbox.draw();                            gameButtons[0].draw();                            gameButtons[1].draw("Score: " + toString(mainMap.getScore()));                            gameButtons[2].draw("Rockets: " + toString(mainMap.rockets_));                            gameButtons[3].draw("Digs: " + toString(mainMap.digs_));                            gameButtons[4].draw("Mines: " + toString(mainMap.getTotalMines()));                            SDL_RenderPresent(renderer);                        }                        else if (subcode == 0)                        {                            close = true;                            if(mainMap.getScore() != 0){                                scores.push_back(mainMap.getScore());                                quicksort(scores,0,scores.size()-1);                            }                        }                    }                }                if(SDL_PointInRect(&mouse,gameButtons[1].rect()))                {                    int code = gameButtons[1].showScoresheet(ev,scores);                    if(code == 0){                        close = true;                        if(mainMap.getScore() != 0){                            scores.push_back(mainMap.getScore());                            quicksort(scores,0,scores.size()-1);                        }                    }                }                // * Convert mouse coordinates to tile coordinates                int posX = ((mouse.x+mainMap.offsetX())/mainMap.tileSize());                int posY = ((mouse.y+mainMap.offsetY())/mainMap.tileSize());                if(mainMap[posX][posY].getType() != 2)                {                    // * Position of person/camera (3 by 3)                    if ((character.posX() - mainMap.tileSize() - mainMap.offsetX() - 8) < mouse.x && mouse.x < (character.posX() + 2*mainMap.tileSize() - mainMap.offsetX() - 8) &&                        (character.posY() - mainMap.tileSize() - mainMap.offsetY() - 8) < mouse.y && mouse.y < (character.posY() + 2*mainMap.tileSize() - mainMap.offsetY() - 8))                    {                        if(mainMap.digs_ > 0)                        {                            // * Plays the dig noise if inside the 3 by 3 (digging noise)                            Mix_PlayChannel(0, dig, 0 );                            mainMap.clearTile(posX,posY,'d');                        }                    }                    else                    {                        if (mainMap.rockets_ > 0)                        {                            rocket.pathParabola(mouse.x,mouse.y,&character);                            mainMap[posX][posY].detonate();                            // * Plays the explosion sound if beyond 3 by 3 (boom noise)                            Mix_PlayChannel(0, boom, 0 );                            mainMap.rocketExplosion(posX,posY);                            // mainMap.clearTile(posX,posY,'r');                        }                    }                }                gameButtons[1].draw("Score: " + toString(mainMap.getScore()));                gameButtons[2].draw("Rockets: " + toString(mainMap.rockets_));                gameButtons[3].draw("Digs: " + toString(mainMap.digs_));                gameButtons[4].draw("Mines: " + toString(mainMap.getTotalMines()));                SDL_RenderPresent(renderer);                SDL_RenderClear(renderer);                mainMap.draw();                character.draw();                textbox.draw();                for(int i = 0; i < gameButtons.size(); i++)                {                  gameButtons[i].draw();                }                SDL_RenderPresent(renderer);            }        }    }    }    saveScores(scores);    SDL_DestroyRenderer(renderer);	SDL_DestroyWindow(win);	IMG_Quit();	SDL_Quit();    //delete[] imageVector;	return 0;    }